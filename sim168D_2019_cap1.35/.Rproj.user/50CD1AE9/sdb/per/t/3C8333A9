{
    "collab_server" : "",
    "contents" : "\n## Sim168 Evolution of sociality -- density based on TotConsumption, \n## with sharing gamma and childhood sharing gamma factors, both with \n## elasticities of 0.5\n\n## Cap on childhood sharing gamma is set to 1.25\n\n## N\n## subgroups grow independently, except coupled through total density;\n## The  pops follow three of Maternal, kin5,  kin5 50/50 kin/sg sharing,\n## and so the only difference between the populations is from random\n## initial configuration and demographic randomness of events, and their sharing dynamics.  ##\n\n# forward.5yr.altqx.Tcons.sociality\n\n## No dispersion\nsource(\"f.Timapply.R\")\n\n\nforward.5yr.altqx <-\n  function (cycleno,\n            beta.mat,\n            beta.kin,\n            beta.sg1,\n            own.id.mat,\n            mom.id.mat,\n            gmom.id.mat,\n            ggmom.id.mat,\n            mom.id.kin,\n            gmom.id.kin,\n            ggmom.id.kin,\n            gggmom.id.kin,\n            ggggmom.id.kin,\n            gggggmom.id.kin,\n            kinship3.id,\n            kinship4.id,\n            kinship5.id,            \n            group.id.anc,\n            own.id.yr,\n            mom.id.yr,\n            gmom.id.yr,\n            ggmom.id.yr,\n            gggmom.id.yr,\n            group.id.mat,\n            gamma.mat,\n            childhood.gamma.mat,\n            gamma.kin,\n            childhood.gamma.kin,\n            gamma.anc,\n            childhood.gamma.anc,\n            #own.id.sg1,\n            mom.id.sg1,\n            gmom.id.sg1,\n            ggmom.id.sg1,\n            group.id.sg1,\n            gamma.sg1,\n            childhood.gamma.sg1,\n            sharing.gamma,\n            sharing.childhood.gamma,\n            subPop.id,       #new vector to track subpopulations\n            gene,\n            age,\n            max.age,\n            e.fertility,\n            e.mortality,\n            e.production,\n            e.cproduction,\n            cproduction.cap = 5.0,  # childhood production factor cap: min(c.production.cap, csg^e.cproduction)\n            e.density = -0.2,\n            #pop.size= length(own.id.mat);\n            resource.size=1e5\n            )\n{\n  ## Carl Boe\n  ## Tim Miller\n  ## July 23, 2005\n  ## This function projects population one year forward in time.\n   \n   \n  \n    ############################################################################\n    # Step 1. Assign degree of food sharing from Matriarchy versus Social Group.\n    ############################################################################\n\n\n\n  ## the sharing parameter gamma is a weighted average of the sharing\n  ## within matriarchies, sharing within kinship lines, and sharing\n  ## within social groups.  The betas add to 1.  When beta.sg1=1, then\n  ## sharing only takes place within social groups.\n\n  ## Data-check: does sharing.gamma*consumption sum to production?\n\n  ## Gamma is measure of actual consumption relative to baseline\n  ## consumption needs (age pattern taken from Ache).\n\n  ## NB: gamma values persevere from the end of the previous cycle and\n  ## are recalculated as the last stage of this program\n  \n\n      #####################################################################\n      # Step 2. Define density as *effective* population size divided by resource size.\n      #####################################################################\n\n      # Resource size is an arbitary constant which sets the equilibrium\n      # population size.  A larger value of resources leads to lower density and\n      # increased productivity and a larger equlibrium population size.\n      # Resource size can be set at a fixed value for the duration of the simulation\n      # or alternatively, can be updated periodically (not too frequently!)\n      # during the simulation to insure a final equilibrium\n      # population size of about N individuals.\n\n      # redefine 'population' to be consumption-weighted population across *all* subgroups\n      totC <- sum(cxz[age+1]);          #sum of each i's age-indexed consumption\n      density <- sum(totC) /resource.size;\n\n      #############################################\n      # Step 3.  Births in the year to those age x.\n      #############################################\n\n      #  gave.birth == 1, indicating which moms give birth\n      adjust.fx <-  sharing.gamma^(e.fertility)\n      gave.birth <- rep(0,length(age))\n      gave.birth[ runif(length(age)) < (fx[age+1])*adjust.fx ] <- 1\n\n      #Newborns inherit mom's genes.\n      newborn.gene <-  gene[gave.birth==1,]\n\n      # Mutations in genes\n      mutants <- rep(0,length(newborn.gene))\n      mutants[runif(length(newborn.gene))<mute.rate] <- 1 # spontaneous mutation\n      newborn.gene <- newborn.gene + as.integer(mutants)\n      ## storage.mode(newborn.gene) <- \"integer\"; # ?? needed ?\n\n      ## Newborns are age 0\n      newborn.age <- rep(as.integer(0),sum(gave.birth))\n      newborn.qx  <- newborn.age;       #newborns survive the first interval\n\n      # Newborns inherit mom's ids and gamma values, and association (subPop) values\n      gave.birth.isel <- (gave.birth==1); # used repeatedly, so calc once\n      newborn.ggmom.id.sg1 <- gmom.id.sg1[gave.birth.isel]\n      newborn.gmom.id.sg1 <-  mom.id.sg1[gave.birth.isel]\n      newborn.mom.id.sg1 <-   own.id.mat[gave.birth.isel]; # own.id for sg1 is same as for .mat\n      newborn.group.id.sg1 <-   group.id.sg1[gave.birth.isel]\n      newborn.subPop.id <- subPop.id[gave.birth.isel]; # congenital association meme\n      \n      #newborn.own.id.sg1   <- as.integer(max(own.id.sg1) + seq(1,length(newborn.age)) )\n      newborn.gamma.sg1 <-    gamma.sg1[gave.birth.isel]\n      newborn.ggmom.id.mat <- gmom.id.mat[gave.birth.isel]\n ##     newborn.gggmom.id.mat <- ggmom.id.mat[gave.birth.isel]\n      newborn.gmom.id.mat <-  mom.id.mat[gave.birth.isel]\n      newborn.mom.id.mat <-   own.id.mat[gave.birth.isel]\n      newborn.group.id.mat <-   group.id.mat[gave.birth.isel]\n      newborn.own.id.mat   <- as.integer(max(own.id.mat) + seq(newborn.age))      \n      newborn.gamma.mat <-    gamma.mat[gave.birth.isel]\n      newborn.gamma.kin <-    gamma.kin[gave.birth.isel]\n      # Tim's .anc measure\n      newborn.gamma.anc <-    gamma.anc[gave.birth.isel]\n      newborn.group.id.anc <-   group.id.anc[gave.birth.isel]\n      newborn.sharing.gamma <- sharing.gamma[gave.birth.isel]\n      newborn.sharing.childhood.gamma <- sharing.childhood.gamma[gave.birth.isel]\n      \n\n ## new stuff for kin-based measurements      \n      newborn.mom.id.kin <-    newborn.mom.id.mat; # newborns get mom ids regardless of .mat, .kin, .sg1\n      newborn.gmom.id.kin <-  mom.id.kin[gave.birth.isel]\n      newborn.ggmom.id.kin <-  gmom.id.kin[gave.birth.isel]\n      newborn.gggmom.id.kin <-  ggmom.id.kin[gave.birth.isel]\n      newborn.ggggmom.id.kin <-  gggmom.id.kin[gave.birth.isel]\n      newborn.gggggmom.id.kin <-  ggggmom.id.kin[gave.birth.isel]\n      \n      #newborn.kinship.id  <-  kinship.id[gave.birth.isel] # assignment not needed, recomputed below\n      \n      # newborn birth year info\n      newborn.own.id.yr   <-   as.integer(rep(cycleno,length(newborn.age)) );\n      newborn.mom.id.yr   <-   own.id.yr[gave.birth.isel]\n      newborn.gmom.id.yr   <-  mom.id.yr[gave.birth.isel]\n      newborn.ggmom.id.yr   <-  gmom.id.yr[gave.birth.isel]\n      newborn.gggmom.id.yr   <-  ggmom.id.yr[gave.birth.isel] \n\n      \n      ###################################################\n      # STEP 4.  Survive the population from age x to x+1.\n      ####################################################\n\n      # Some people die\n      # effect of phenotype\n      # mortality consists of two separable components, working on the hazard.  There is\n      # (1) a component indexing the lethality of genetic mutations;\n      # (2) a gamma-dependent component that indicates nutrition or other effect of resources\n      \n      lethality <- additive.gene.risk ; # CAB: use more appropriate name for this setting under\n\n\n                                   # new mortality formulation\n      gene.risk <- rep( as.integer(0),length(age));\n      for (cnt in seq(gene.risk)){\n        # get mutation load for each ind. at that individual's current age.\n        gene.risk[cnt] <-  ( gene[cnt,][[(age[cnt]+1)]] ); # CAB: just the mutation count\n      };\n\n      ## new mortality formulation, see RLee memo 10/2/06 and subsequent email.  New\n      ## hazard formulation is h(x) = K(x)*delta + background.mort * gamma^alpha (K is mutation count, delta is lethality,\n      ##  epsilon is the level of background mortality, gamma is a resource, e.g. food consumption; epsilon\n      ##  set to .01 corresponds to a background 1qx of .01 \n        \n      ## the baseline hazard is the -log(1-q_base)/5 for 5yr age groups.  But, we keep it in the qx form\n      ## to avoid problems with log(0) or an infinity hazard rate.\n      adjust.hx <- (gene.risk*lethality  + background.mort ) * sharing.gamma^(e.mortality) ;\n       # incorporate baseline with gene-dependent mortality\n      qx.risk <- 1 - (1 - qx.baseline[age+1])*( exp( -5*adjust.hx)  ) ;\n\n      died <- (runif(length(age)) <= qx.risk ); #logical\n      died.id <- own.id.mat[died] # ID of those who died\n\n## new stuff: we keep a history of the death probabilities so we can look at a distribution over time\n## and get some feel for the variation\n\n      died.by.age.subpop <- tapply(died,\n                                   list(factor(age,levels=0:15),factor(subPop.id,levels=seq(subPopTypes))),\n                                   sum);\n      pop.by.age.subpop <- tapply(rep(1,length(died)),\n                                   list(factor(age,levels=0:15),factor(subPop.id,levels=seq(subPopTypes))),\n                                   sum);\n\n      qx.by.age.subpop <- ifelse(pop.by.age.subpop==0, NA, died.by.age.subpop/pop.by.age.subpop);\n      \n      #died.by.age <- timapply2(died, age,sum);\n      #pop.by.age  <- timapply2(rep(1,length(died)),age,sum);\n      #qx.by.age   <- died.by.age / pop.by.age; # cohort mortality, a 16-vector\n      #qx.by.age <- ifelse( is.nan(qx.by.age),1,qx.by.age);\n      #On death, remove rows of those who died\n\n      age <- age[!died]\n      gene <- gene[!died,]\n      gamma.sg1 <- gamma.sg1[!died]\n      childhood.gamma.sg1 <- childhood.gamma.sg1[!died]\n      gamma.mat <- gamma.mat[!died]\n      childhood.gamma.mat <- childhood.gamma.mat[!died]\n      gamma.kin <- gamma.kin[!died]\n      childhood.gamma.kin <- childhood.gamma.kin[!died]\n      childhood.gamma.anc <- childhood.gamma.anc[!died]\n      gamma.anc <- gamma.anc[!died]\n      sharing.gamma <- sharing.gamma[!died]\n      sharing.childhood.gamma <- sharing.childhood.gamma[!died]\n\n      age <- age+ as.integer( 1 ) # age population by 1 year\n      age[age>max.age] <- max.age\n\n      qx.risk <- qx.risk[!died];\n      \n      ##own.id.sg1 <- own.id.sg1[!died]   ## DELETE THIS\n      mom.id.sg1 <- mom.id.sg1[!died]\n      gmom.id.sg1 <- gmom.id.sg1[!died]\n      ggmom.id.sg1 <- ggmom.id.sg1[!died]\n      group.id.sg1 <- group.id.sg1[!died]\n      own.id.mat <- own.id.mat[!died]\n      mom.id.mat <- mom.id.mat[!died]\n      gmom.id.mat <- gmom.id.mat[!died]\n      ggmom.id.mat <- ggmom.id.mat[!died]\n      ##gggmom.id.mat <- gggmom.id.mat[!died]\n      group.id.mat <- group.id.mat[!died]\n      subPop.id <- subPop.id[!died];\n      \n      ## new stuff for kin-based measurements      \n      mom.id.kin <-  mom.id.kin[!died]      \n      gmom.id.kin <-  gmom.id.kin[!died]   \n      ggmom.id.kin <- ggmom.id.kin[!died]\n      gggmom.id.kin <- gggmom.id.kin[!died]\n      ggggmom.id.kin <- ggggmom.id.kin[!died]\n      gggggmom.id.kin <- gggggmom.id.kin[!died]\n      \n      ##kinship.id recomputed later\n\n      ## Tim's ancestor id\n      group.id.anc <- group.id.anc[!died]\n\n      \n      own.id.yr <- own.id.yr[!died]\n      mom.id.yr <- mom.id.yr[!died]\n      gmom.id.yr <- gmom.id.yr[!died]\n      ggmom.id.yr <- ggmom.id.yr[!died]\n      gggmom.id.yr <- gggmom.id.yr[!died] \n\n      ##ADD in NEWBORNS\n      age <- c(age,newborn.age)\n      gene <- rbind(gene,newborn.gene)\n      ##own.id.sg1 <- c(own.id.sg1,newborn.own.id.sg1)  # DELETE \n      mom.id.sg1 <- c(mom.id.sg1,newborn.mom.id.sg1)\n      gmom.id.sg1 <- c(gmom.id.sg1,newborn.gmom.id.sg1)\n      ggmom.id.sg1 <- c(ggmom.id.sg1,newborn.ggmom.id.sg1)\n      group.id.sg1 <- c(group.id.sg1,newborn.group.id.sg1)\n      gamma.sg1 <- c(gamma.sg1,newborn.gamma.sg1)\n      childhood.gamma.sg1 <- c(childhood.gamma.sg1,newborn.gamma.sg1)\n      own.id.mat <- c(own.id.mat,newborn.own.id.mat)\n      mom.id.mat <- c(mom.id.mat,newborn.mom.id.mat)\n      gmom.id.mat <- c(gmom.id.mat,newborn.gmom.id.mat)\n      ggmom.id.mat <- c(ggmom.id.mat,newborn.ggmom.id.mat)\n      ##gggmom.id.mat <- c(gggmom.id.mat,newborn.gggmom.id.mat)\n      group.id.mat <- c(group.id.mat,newborn.group.id.mat)\n      subPop.id  <- c(subPop.id, newborn.subPop.id);\n      gamma.mat <- c(gamma.mat,newborn.gamma.mat)\n      childhood.gamma.mat <- c(childhood.gamma.mat,newborn.gamma.mat)\n      \n      ##new stuff for kin-based measurements\n      mom.id.kin <- c(mom.id.kin,newborn.mom.id.kin)\n      gmom.id.kin <- c(gmom.id.kin,newborn.gmom.id.kin)\n      ggmom.id.kin <- c(ggmom.id.kin,newborn.ggmom.id.kin)\n      gggmom.id.kin <- c(gggmom.id.kin,newborn.gggmom.id.kin)\n      ggggmom.id.kin <- c(ggggmom.id.kin,newborn.ggggmom.id.kin)\n      gggggmom.id.kin <- c(gggggmom.id.kin,newborn.gggggmom.id.kin)\n      \n      gamma.kin <- c(gamma.kin,newborn.gamma.kin)\n      childhood.gamma.kin <- c(childhood.gamma.kin,newborn.gamma.kin)\n\n      # Tim's ancestor measure\n      gamma.anc <- c(gamma.anc,newborn.gamma.anc)\n      childhood.gamma.anc <- c(childhood.gamma.anc,newborn.gamma.anc)\n      sharing.gamma <- c(sharing.gamma, newborn.sharing.gamma)\n      sharing.childhood.gamma <- c(sharing.childhood.gamma, newborn.sharing.childhood.gamma);\n      \n      group.id.anc <- c(group.id.anc,newborn.group.id.anc)\n\n      \n      own.id.yr <- c(own.id.yr,newborn.own.id.yr)\n      mom.id.yr <- c(mom.id.yr,newborn.mom.id.yr)\n      gmom.id.yr <- c(gmom.id.yr,newborn.gmom.id.yr)\n      ggmom.id.yr <- c(ggmom.id.yr,newborn.ggmom.id.yr)\n      gggmom.id.yr <- c(gggmom.id.yr,newborn.gggmom.id.yr)\n      \n      #########################################################################\n      # STEP 5.  Update kin groups and matriarchies \n      #########################################################################\n\n\n\n      ##\n      kinship3.id <- NULL; kinship4.id <- NULL; kinship5.id <- NULL;\n      #kinship3.id <-  f.kinshipid3(gggmom.id.kin, ggmom.id.kin, gmom.id.kin, mom.id.kin,own.id.mat)\n      #kinship4.id <- f.kinshipid4(ggggmom.id.kin, gggmom.id.kin, ggmom.id.kin, gmom.id.kin, mom.id.kin,own.id.mat)\n      kinship5.id <- f.kinshipid5(gggggmom.id.kin,ggggmom.id.kin, gggmom.id.kin, ggmom.id.kin, gmom.id.kin, mom.id.kin,own.id.mat)\n\n      \n\n      # Older measure of matriarchy; for reference\n      #On death, replace ids used to identify matriarchies with NAs\n\n      mom.id.mat[mom.id.mat %in% died.id] <- NA\n      gmom.id.mat[gmom.id.mat %in% died.id] <- NA\n      ggmom.id.mat[ggmom.id.mat %in% died.id] <- NA\n\n      group.id.mat <- ggmom.id.mat\n      group.id.mat[is.na(group.id.mat)] <- gmom.id.mat[is.na(group.id.mat)]\n      group.id.mat[is.na(group.id.mat)] <- mom.id.mat[is.na(group.id.mat)]\n      group.id.mat[is.na(group.id.mat)] <- own.id.mat[is.na(group.id.mat)]\n\n      #########################################################################\n      # STEP 5b.  Calculate ancestory ids\n      #########################################################################\n      # ancestor id is the grand grandmom of the matriarch\n\n      ## Need a sort of look-up table to match matriarchy id with anc id (which is ggmom of matriarchs)\n      is.matriarch <- group.id.mat == own.id.mat # T = matriarch\n      matriarchies <- group.id.mat[is.matriarch==TRUE]\n      ancestories <-  ggmom.id.kin[is.matriarch==TRUE]; # ggmom.id.kin is the same as tim's ggmom.id.anc\n\n      locate <- match(group.id.mat, matriarchies)\n      group.id.anc <- ancestories[locate]\n\n\n\n      ######################################################################\n      # STEP 5.5 Randomly reassign kinship members into different groups\n      ######################################################################\n\n      ## Because kin groups are always in in the same subpopulation, we can operate at the population level\n      \n      # Every n cycles, randomly put all members of a kin group into a different social group. \n      ## no dispersion, set the freq to 0 ##\n    if(setDispersal !=  'useNone'){        #skip this section\n      disperse.freq <- 0;               # freq in cycles of  the dispersion event; 0 disables \n      if(disperse.freq != 0 &&  (cycleno %% disperse.freq) == 0 ){\n      # List of social group foreach kin line\n        weighted.list.of.sg.ids <- group.id.sg1[!duplicated(kinship5.id)]\n\n      #Randomly re-assign this list\n        random.list.of.sg.ids <- sample(weighted.list.of.sg.ids,\n                                        length(weighted.list.of.sg.ids),\n                                        replace=T)\n      # Create a look-up table to match kinship id with new\n      # randomly assign sg1\n        random.id.sg1 <- random.list.of.sg.ids[match(kinship5.id,unique(kinship5.id))]\n\n      # Reassign to this new social group\n        group.id.sg1 <- as.integer(random.id.sg1);\n      }\n    };\n      \n      ################################################################\n      # STEP 6  Fission (splitting along maternal ancestor lines)\n      ################################################################\n      \n      Pfissions=NA;\n   \n      ## Splitting happens when kinship lines (as measured by\n      ## kinship.id) get too big. Unless splitting or dispersion happens, the\n      ## social group is mostly the maternal group.\n      \n      #print(\"...Step 5.5\");\n      fission.size <- 25   \n\n    if(setFission=='useTMpk5fission'){\n      \n      ## kinship5 groups are kept together in the splits, and kin5\n      ## groups do not overlap subpop boundaries. So, there is no need\n      ## to iterate over subpops, but we do anyway, because we want the subpop detail\n\n      Pfissions <- NA + seq(subPopTypes);# container of dim=#subpops\n      t.subPops <- seq(subPopTypes);\n      for( iSub in (t.subPops) ){\n        isel <- (t.subPops[iSub] == subPop.id ) ;\n        t.thistype <- subPopTypes[iSub]; # regime type of this subpop\n        t.group.id.sg1 <- group.id.sg1[isel]; #subpop specific group\n\n        ## Find Big Groups\n        group.size <- table(t.group.id.sg1)\n        fission.size <- 25\n        big.group.size <- group.size[group.size > fission.size]\n        big.groups <- as.numeric(names(big.group.size))\n\n        ##Create new group IDs for big groups.\n        new.big.group.id.sg1 <- max(group.id.sg1)+seq(big.groups)\n\n        ##Fission the groups within subpops\n        new.group.id.sg1 <- t.group.id.sg1\n        locate <- match(new.group.id.sg1,big.groups)\n        new.group.id.sg1[!is.na(locate)] <- new.big.group.id.sg1[locate[!is.na(locate)]]\n        ## Re-assign about half of population to original groups if kinship id is an odd integer.\n        ## This keeps kinships from being split when the social group fissions.\n        t.kinship <- kinship5.id[isel];\n        odd.integer <- (t.kinship  > (2*floor( t.kinship /2)) )\n        new.group.id.sg1[odd.integer] <- t.group.id.sg1[odd.integer]\n        group.id.sg1[isel] <- as.integer(new.group.id.sg1);\n        Pfissions[iSub] <- length(big.group.size)/length(group.size);\n      }\n      \n    }; #end if setFission\n \n\n      ##########################################################\n      # STEP 7.  Fuse social groups which have too few members.\n      ##########################################################\n\n      ## The strategy here is similar to the fission computation.  We\n      ## order groups defined by group.id.sg1 according to size, with\n      ## the smallest first.  Next process all the groups with size\n      ## falling below the fusion.size threshold. For each small\n      ## group, fuse them to the group which has the highest\n      ## relatedness index (based on kinship.id, gggmom.id, etc.) and\n      ## which can accomodate the small group.  \n      \n      ##print(\"...Step 6 fusion\");     \n      # Find Small Groups\n\n      Pfusions = NA;\n      \n\n    if(setFusion=='useTMfusion'){\n      Pfusions <- NA+ seq(subPopTypes);# container of dim=#subpops\n      \n      ## Find Small Groups\n\n      \n      t.subPops <- seq(subPopTypes);\n      for( iSub in (t.subPops) ){\n        isel <- (t.subPops[iSub] == subPop.id ) ;\n        t.group.id.sg1 <- group.id.sg1[isel]; #subpop specific group\n        group.size <- table(t.group.id.sg1)\n        fusion.size <- 8\n        small.group.size <- group.size[group.size<fusion.size]\n        small.groups <- as.numeric(names(small.group.size))\n      \n        if(length(small.groups)>1){ # Must have at least 2 groups\n          ## Combine small groups two at a time.\n          ## Take half of the ids of small groups.\n          ## These groups will be eliminated.\n          small.groups.eliminated <- small.groups[seq(2,length(small.groups),2)]\n          ## Take the other half of the id of small groups.\n          ## These groups will receive new members.\n          small.groups.receive <- small.groups[seq(1,length(small.groups),2)]\n\n          ## Assign new group ids to each individual\n          new.group.id.sg1 <- t.group.id.sg1;\n          ## Find those in small groups which are to be eliminated\n          locate <- match(t.group.id.sg1,small.groups.eliminated)\n          ## Assign them to other small groups\n          new.group.id.sg1[!is.na(locate)] <- small.groups.receive[locate[!is.na(locate)]]\n          ## we have reassigned groups within the subpopulation; write out the results\n          ## but just for the subpopulation\n          group.id.sg1[isel] <- as.integer(new.group.id.sg1);\n          Pfusions[iSub] <- length(small.group.size)/length(group.size);\n        }\n      } # end for(iSub\n      \n    } #end setFusion \n\n      ################################################################################################\n      # STEP 8.  Update economic variables based on new composition of matriarchies and social groups.\n      ################################################################################################\n      ##print(\"...Step 8\");\n\n      ### all of the gamma computations involve restrictions to the subpopulation level.\n      ### Therefore, we loop through the entire gamma calculation set at one time\n\n      ## production is a function of prior sharing gammas which are passed into this routine\n\n\n      \n## begin loop      \n      t.subPops <- seq(subPopTypes);\n      yx <- NA + (own.id.mat);\n      \n      for( iSub in (t.subPops) ){\n        isel <- (t.subPops[iSub] == subPop.id ) ;\n        t.group.id.sg1 <- group.id.sg1[isel]; #subpop specific group\n        t.group.id.mat <- group.id.mat[isel]; #subpop specific group\n        t.age <- age[isel];             #subpop specific ages\n        t.scg <-  sharing.childhood.gamma[isel]\n        t.sg <-  sharing.gamma[isel]\n        t.kinship5.id <- kinship5.id[isel];\n        t.group.id.anc <- group.id.anc[isel];\n      \n      ##################################################################################\n      # STAGE 8a. Find gamma (relative consumption) based on membership in social group.\n      ##################################################################################\n\n     # Sum of consumption weights within each social group, specific within each subpopulation\n        c.group <- tapply(cxz[t.age+1],t.group.id.sg1,sum)\n        g.group.ids <- as.integer(names(c.group))\n        c.group <- as.numeric(c.group)\n\n        ## Sum of production weights within each social group\n        t.yx <- yxz[t.age+1] * pmin(t.scg^(e.cproduction), cproduction.cap) * (t.sg^(e.production))\n        t.yx <- t.yx * (density^e.density); ## !! GLOBAL density\n        p.group <- as.numeric(tapply( t.yx,t.group.id.sg1,sum))\n\n        ## Define gamma parameter for each subpopulation\n        g.group <- p.group/c.group\n\n        ## Assign gamma to members of group\n        gamma.sg1[isel] <- g.group[match(t.group.id.sg1,g.group.ids)]\n      \n\n      ################################################################################\n      # Step 8b.  Find gamma (relative consumption) based on membership in matriarchy.\n      #################################################################################\n\n      ## Sum of consumption weights within each matriarchy\n        c.group <- tapply(cxz[t.age+1],t.group.id.mat,sum)\n        g.group.ids <- as.integer(names(c.group))\n        c.group <- as.numeric(c.group)\n\n      ## Sum of production weights within each social group -- already computed\n        #yx <- yxz[t.age+1]*(t.scg ^(e.production))*(t.sg^(e.production))\n        #yx <- yx * (density^e.density)\n        p.group <- as.numeric(tapply(t.yx,t.group.id.mat,sum))\n\n      ## Define gamma parameter for each social group\n        g.group <- p.group/c.group\n\n      ## Assign gamma to members of group\n        gamma.mat[isel] <- g.group[match(t.group.id.mat,g.group.ids)]\n\n      ################################################################################\n      # Step 8c.  Find gamma (relative consumption) based on membership in kinship group\n      #################################################################################\n\n        ## Sum of consumption weights within each kinship group\n        c.group <- tapply(cxz[t.age+1],t.kinship5.id,sum)\n        g.group.ids <- as.integer(names(c.group))\n        c.group <- as.numeric(c.group)\n\n        ## Sum of production weights within each kinship group -- already computed above\n        #yx <- yxz[t.age+1]*(t.scg^(e.production))*(t.sg ^(e.production))\n        #yx <- yx * (density^e.density)\n        p.group <- as.numeric(tapply( t.yx,t.kinship5.id,sum))\n\n        ## Define gamma parameter for each kinship group\n        g.group <- p.group/c.group\n\n        ## Assign gamma to members of kinship group\n        gamma.kin[isel] <- g.group[match(t.kinship5.id,g.group.ids)]\n\n     #################################################################################\n     # Step 8c.  Find gamma (relative consumption) based on membership in ancestory group.\n     #################################################################################\n\n\n        ## Sum of consumption weights within each related group\n        c.group <- tapply(cxz[t.age+1],t.group.id.anc,sum)\n        g.group.ids <- as.numeric(names(c.group))\n        c.group <- as.numeric(c.group)\n\n        ## Sum of production weights within each  group  -- already computed\n        #yx <- yxz[t.age+1]*(t.scg^(e.production))*(t.sg^(e.production))\n        #yx <- yx * (density^e.density)\n        p.group <- as.numeric(tapply( t.yx,t.group.id.anc,sum))\n\n        ## Define gamma parameter for each  group\n        g.group <- p.group/c.group\n\n        ## Assign gamma to members of group\n        gamma.anc[isel] <- g.group[match(t.group.id.anc,g.group.ids)]\n\n        ## save the production information for the subgroup into the whole container\n        yx[isel] <- t.yx;\n\n      } # for(iSub ...\n\n     #################################################################################\n     ## Step 8d.  Compute sharing gamma based on component sg,kin,mat gammas\n     #################################################################################\n      ##\n      ## each subpopulation has its own type of sharing gamma calculation;\n      ## so do each subpop separately\n      \n      t.subPops <- seq(subPopTypes)\n      for( iSub in (t.subPops) ){\n        isel <- (t.subPops[iSub] == subPop.id ) ;\n        t.thistype <- subPopTypes[iSub]; # regime type of this subpop\n        if(t.thistype == 1){                    # Matriarchal\n          t.beta.sg1 = 0; t.beta.kin=0; t.beta.mat = 1;\n        }\n        if(t.thistype == 2){                    # 100% kinN\n          t.beta.sg1 = 0; t.beta.kin=1; t.beta.mat = 0;\n        }\n        if(t.thistype == 3){                    # mix of social and kin, no maternal\n          t.beta.sg1 = .5; t.beta.kin=.5; t.beta.mat = 0;\n        }\n\n        sharing.gamma[isel] <- ( t.beta.sg1 *gamma.sg1[isel] ) + (t.beta.kin * gamma.kin[isel] ) +\n          ( t.beta.mat*gamma.mat[isel] );\n        sharing.childhood.gamma[isel] <- ( t.beta.sg1*childhood.gamma.sg1[isel] ) +\n          (t.beta.kin * childhood.gamma.kin[isel]) + ( t.beta.mat *childhood.gamma.mat[isel] );\n      };\n \n      \n      \n     ###############################\n     # Step 9.  Summarize the data.\n     ###############################\n\n     # average number of mutant genes carried by newborns\n      mean.harm <- apply(newborn.gene,2,mean)\n\n \n      result <- list(own.id.mat=own.id.mat,\n                     mom.id.mat=mom.id.mat,\n                     gmom.id.mat=gmom.id.mat,\n                     ggmom.id.mat=ggmom.id.mat,\n                     ##gggmom.id.mat=gggmom.id.mat,\n                       \n                     mom.id.kin = mom.id.kin,\n                     gmom.id.kin = gmom.id.kin,\n                     ggmom.id.kin = ggmom.id.kin,\n                     gggmom.id.kin = gggmom.id.kin ,\n                     ggggmom.id.kin = ggggmom.id.kin ,\n                     gggggmom.id.kin = gggggmom.id.kin ,\n                     kinship3.id = kinship3.id,\n                     kinship4.id = kinship4.id,\n                     kinship5.id = kinship5.id,                     \n                     group.id.anc=group.id.anc, #Tim's ancestory grouping variable\n                     own.id.yr = own.id.yr,\n                     mom.id.yr = mom.id.yr,\n                     gmom.id.yr = gmom.id.yr,\n                     ggmom.id.yr=ggmom.id.yr,\n                     gggmom.id.yr = gggmom.id.yr,                                       \n                     group.id.mat = group.id.mat,\n                     gamma.mat = gamma.mat,\n                     childhood.gamma.mat = childhood.gamma.mat,\n                     gamma.kin = gamma.kin,\n                     childhood.gamma.kin = childhood.gamma.kin, \n                     gamma.anc = gamma.anc, #new\n                     childhood.gamma.anc = childhood.gamma.anc, #new\n                     ##own.id.sg1 = own.id.sg1,  # DELETE\n                     mom.id.sg1 = mom.id.sg1,\n                     gmom.id.sg1 = gmom.id.sg1,\n                     ggmom.id.sg1 = ggmom.id.sg1,                                  \n                     group.id.sg1 = group.id.sg1,\n                     gamma.sg1 = gamma.sg1,\n                     childhood.gamma.sg1 = childhood.gamma.sg1,\n                     sharing.gamma = sharing.gamma,\n                     sharing.childhood.gamma = sharing.childhood.gamma,     \n                     subPop.id=subPop.id,\n                     gene=gene,\n                     age=age,                   \n                     mean.harm=mean.harm,\n                     yx=yx,\n                     c.group=c.group,\n                     p.group=p.group,\n                     g.group=g.group,\n                     Pfissions=Pfissions,\n                     Pfusions=Pfusions,\n                     qx.by.age=qx.by.age.subpop\n                     )\n      return(result)\n  }           \n                                \n         \n          \n",
    "created" : 1547392239102.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3186392493",
    "id" : "3C8333A9",
    "lastKnownWriteTime" : 1547704147,
    "last_content_update" : 1547704147769,
    "path" : "/data/nta0/boe/EvoSims/sim168D_2019/forward.5yr.altqx.Tcons.sociality.r",
    "project_path" : "forward.5yr.altqx.Tcons.sociality.r",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}