{
    "collab_server" : "",
    "contents" : "## sim168D_2019.  Redo of sim168B with childhood sharing gamma effect limited to a factor of 1.25\n\n## to see if the winning strategy changes\n\n## 9 independent groups compete with weak\n## density dependence.  There are 3 types of groups, 3 maternal, 3 kin5, and 3 with 50/50 (kin5) sharing\n\n\n## new density measurement, based on consumption weighted population.\n\n## New mortality variant  h(x) = *K(x)*delta + xi)*gamma^(e.mortality)\n\noptions(save.defaults=list(compress=TRUE)); #avoid unnecessarily huge files\nlibrary(compiler)\n\n## load in and save the results of the individual type simulations\nload(\".CheckPointA\");                   #Maternal type\ntestA <- test;\nload(\".CheckPointB\");                   #two kin5 type\ntestB <- test;\nload(\".CheckPointC\");                   #two 50/50 types\ntestC <- test;\n\n\nstart.time <- date()\n  \nsource(\"forward.5yr.altqx.Tcons.sociality.r\");         #main simulation routine\nsource(\"lifetable.1qx.r\")\n#source(\"f.disperse.r\");\nsource(\"f.showmode.r\");\nsource(\"f.kinshipidX.R\");                #define CB kinship algorithms.\nsource(\"f.Timapply.R\");\n#############################################################################################\n#############################################################################################\n# Fertility experiments that use different scalings of the baseline ferfility\n# This is controlled with parameter f.adjust.\n\n# \n############################################################################################\n\n\n#############################\n# Control parameters\n############################\nstart.year = 1;                         # launch time\nNcycles =  500;            # number of iterations in this simulation\nNcheckpoint = 200;                      # write out checkpoints at this interval\nsubPopTypes <- c( 1,1,1,  2,2,2,  3,3,3);\n\nsubPopLabels<-   c(\"M\",\"kin5\",\"50/50\")[subPopTypes];\n\nmax.age <- 15;                          # \n\n###############################\n# Input Parameters\n##############################\n\nsim.num <- c(\"Sim 168D_2019\")\nmute.rate <- .01\nadditive.gene.risk <- .1/5;\t\t# effect of a mutation on mortality\nbackground.mort <- 0.005;               # extrinsic mortality, affected by gamma, not genes;\ne.mort <- -1\ne.fert <- 1\ne.prod <- 0.5;\ne.cprod <- 0.5;                           # e.cprod = e.prod normally,\ncprod.cap = 1.5                       #\ne.dens <- -1\n\nadjust.increment <- 0.1\n# beta are sharing mixture weights\nbeta.kin <- 0.50     ;                        # kinship.id indexed kin shares\nbeta.mat <- 0      ;                        # older matriline sharing\n# group sharing beta is 1-beta.kin - beta.mat\nbeta.sg1 <-  (1- beta.kin - beta.mat);\n\ni.popsize <- 100000;                      # initial and target population size; resources will adjust round this level\nf.adjust  <- 1.0;                       #for fertility experiments, 1=baseline\ndispersal.rate <- 0.5;                  # for now, use tim's dispersal\nresources <- 69361 * (i.popsize/100000);# resources was set empirically, scale it for smaller popsizes\n\n## algorithm choices\nsetFusion<-'useTMfusion';               #Fusion of small groups based on odd/even merges; no relatedness preference in merge\nsetFission<-'useTMpk5fission';           #Fission by splitting large social groups; kin groups are kept together in the splits\nsetDispersal<- 'useNone'\n\n\n################################\n# Initialize Population\n################################\n\n###################\n# Initial Mortality\n###################\nqx.baseline <- rep(0,16)\nqx.baseline[16] <- 1.0\npx <- 1-qx.baseline\nlx <- c(1,cumprod(px)[1:15])\n\n###################\n# Initial Fertility\n###################\nfx <- c(0,0,0.0088,0.1536,0.275,\n        0.298,0.318,0.279,0.219,0.0622,rep(0,6))\nadjust <- sum(fx*lx[1:16])\nfx <- fx/adjust\nfx <- fx* f.adjust;\n\n####################\n# Initial Population\n####################\nf.setinitpop <- function(cname, convert=TRUE){\n  # cname is the component name\n  res<- NULL;\n  t.A <- testA[[cname]];\n  t.B <- testB[[cname]];\n  t.C <- testC[[cname]];\n  \n  if(is.null(dim(t.A))){    \n    res <- c(t.A,t.A,t.A,  t.B,t.B,t.B,  t.C,t.C,t.C);\n  } else {\n    \n    if(cname==\"gene\"){\n      res <- rbind(t.A,t.A,t.A,  t.B,t.B,t.B,  t.C,t.C,t.C);\n    } else {\n      error(\"Houston...we have a problem\")\n    }\n  }\n  if(convert)\n    storage.mode(res) <- \"integer\";\n  \n  return(res)\n}\n  \ni.gamma.sg1 <-f.setinitpop(\"gamma.sg1\",F);\ni.childhood.gamma.sg1 <- f.setinitpop(\"childhood.gamma.sg1\",F);\ni.gamma.mat <-f.setinitpop(\"gamma.mat\",F);\ni.childhood.gamma.mat <-f.setinitpop(\"childhood.gamma.mat\",F);\n\ni.gamma.anc <-f.setinitpop(\"gamma.anc\",F);\ni.childhood.gamma.anc <-f.setinitpop(\"childhood.gamma.anc\",F);\n\ni.gamma.kin <-f.setinitpop(\"gamma.kin\",F);\ni.childhood.gamma.kin <-f.setinitpop(\"childhood.gamma.kin\",F);\n\n\ni.genes <-f.setinitpop(\"gene\");\ni.ages <-f.setinitpop(\"age\");\n\n# Caloric Production among 3 Kaplan populations; see M,F combined C,P schedules\n# in kapconv.xls\nyxz<- # 0:5:90\n      c(0.956462585,158.6018677,640.812987,2065.538596,4807.555662,6180.768293,\n        6180.768293,6180.768293,7093.225806,7093.225806,7378,7378,5035.5,\n        5035.5,3000,3000,1500,1500,0);\n\n\n#yxz <- yxz*1\n\n# Caloric Consumption among 3 hunter gatherer pops; from Kaplan schedules;\n#  see kapconv.xls\ncxz<-# 0:5:90\n  c(1394.606803,2191.669202,2726.972078,3594.029825,3771.813397,3558.792683,\n    3558.792683,3558.792683,3596.451613,3596.451613,3383.083333,3383.083333,\n    2710.7, 2710.7,2500,2500,2000,2000,0);\n\n\n\n\n#adjust <- sum(yxz[i.ages+1])/sum(cxz[i.ages+1])\n#i.gamma.sg1 <- rep(adjust,length(i.ages))\n\n\n#initialize id variables.\n# all the individual pops have ids less than 5000000, so we build up unique ids\n\nf.setinitids <- function(cname,convert=TRUE){\n  # cname is the component name\n  res<- NULL;\n  t.A <- testA[[cname]];\n  t.B <- testB[[cname]];\n  t.C <- testC[[cname]];\n\n  t.s <- 5000000;\n  t.d <- 4000000;\n\n  # make sure the separate groups share no ids\n  res <- c(t.A + t.s,   t.A + t.s + t.d,    t.A + t.s + 2*t.d,\n           t.B + 3*t.s, t.B + t.s + 4*t.d,  t.B + t.s + 5*t.d,\n           t.C + 6*t.s, t.C + t.s + 7*t.d,  t.C + t.s + 8*t.d);\n\n  if(convert)\n    storage.mode(res)<- \"integer\";\n \n  return(res)\n}\n  \ni.own.id.mat <- f.setinitids(\"own.id.mat\");\ni.mom.id.mat <- f.setinitids(\"mom.id.mat\");\ni.gmom.id.mat <- f.setinitids(\"gmom.id.mat\");\ni.ggmom.id.mat <- f.setinitids(\"ggmom.id.mat\");\ni.gggmom.id.mat <-f.setinitids(\"gggmom.id.mat\");\n                  \ni.group.id.mat <- f.setinitids(\"group.id.mat\");\n\ni.own.id.sg1 <- f.setinitids(\"own.id.sg1\");\ni.mom.id.sg1 <- f.setinitids(\"mom.id.sg1\");\ni.gmom.id.sg1 <- f.setinitids(\"gmom.id.sg1\");\ni.ggmom.id.sg1 <-  f.setinitids(\"ggmom.id.sg1\");\ni.group.id.sg1 <-  f.setinitids(\"group.id.sg1\");\n\ni.group.id.anc <-  f.setinitids(\"group.id.anc\");\n\n# extra stuff needed for 18c\n\n  zero <- as.integer( 0 );\n  i.kinship3.id <-   f.setinitids(\"kinship3.id\");\n  i.kinship4.id <-   f.setinitids(\"kinship4.id\");\n  i.kinship5.id <-   f.setinitids(\"kinship5.id\");\n\n  i.own.id.yr <-  zero * f.setinitids(\"own.id.yr\");\n  i.mom.id.yr <- zero * f.setinitids(\"mom.id.yr\");\n\n  i.gmom.id.yr <- zero * f.setinitids(\"gmom.id.yr\");\n  i.ggmom.id.yr <-zero * f.setinitids(\"ggmom.id.yr\");\n  i.gggmom.id.yr <- zero * f.setinitids(\"gggmom.id.yr\");\n\n  i.mom.id.kin <-   f.setinitids(\"mom.id.kin\");\n  i.gmom.id.kin <-  f.setinitids(\"gmom.id.kin\");\n\n  i.ggmom.id.kin <- f.setinitids(\"ggmom.id.kin\");\n\n  i.gggmom.id.kin<- f.setinitids(\"gggmom.id.kin\");\n  i.ggggmom.id.kin<- f.setinitids(\"ggggmom.id.kin\");\n  i.gggggmom.id.kin<- f.setinitids(\"gggggmom.id.kin\");\n\n\n  i.group.id.sg1 <- f.setinitids(\"group.id.sg1\");\n\n\n## with consumption-weighted population size, adjust 'resources' so\n## that the level is comparable with this new measure\n\ni.popsize <- length(i.own.id.mat);      #true init popsize\nresources <- 69361 * (i.popsize/100000);#  population based resource size\nt.TotC <- sum( cxz[i.ages + 1]);           #total consumption across all population\nt.adjust <- t.TotC/i.popsize;\nCresources <- t.adjust * resources;\n\n\n# crudely clump starting population into groups of approx target size to avoid\n# very slow startup; this is not necessary if starting from a prior run\n\n#i.group.id.sg1 <- as.integer( 1+ floor( i.own.id.sg1 / 8) );\n\n# group population into almost equal starting pops, keeping starting clumps together\n#t.nclumps <- length(unique(i.group.id.sg1)); # number of clumps to reassign to subPop types\n#t.isubPop <- 1+ (seq(t.nclumps) %% length(subPopTypes) ); #split up clumps into subPop groupings\n#i.subPop.id <- t.isubPop[match( i.group.id.sg1, seq(t.isubPop) ) ];\n\n#i.subPop.id <- factor(subPopTypes[i.subPop.id],levels=subPopTypes);\n\ni.subPop.id <- c( 1+0*testA$subPop.id, 2+ 0*testA$subPop.id, 3 + 0*testA$subPop.id,\n                  4+0*testB$subPop.id, 5+ 0*testB$subPop.id, 6 + 0*testB$subPop.id,\n                  7 +0*testC$subPop.id, 8 + 0*testC$subPop.id, 9 + 0*testC$subPop.id );\n\ni.subPop.id <- as.integer(i.subPop.id);\n\n# compute initial shared gammas\ni.sharing.gamma <- NA+ i.gamma.mat;\ni.sharing.childhood.gamma <- NA + i.gamma.mat;\n\nt.subPops <- seq(subPopTypes)\nfor( iSub in (t.subPops) ){\n  isel <- (t.subPops[iSub] == i.subPop.id ) ;\n  t.thistype <- subPopTypes[iSub]; # regime type of this subpop\n  if(t.thistype == 1){                    # Matriarchal\n    t.beta.sg1 = 0; t.beta.kin=0; t.beta.mat = 1;\n  }\n  if(t.thistype == 2){                    # 100% kinN\n    t.beta.sg1 = 0; t.beta.kin=1; t.beta.mat = 0;\n  }\n  if(t.thistype == 3){                    # mix of social and kin, no maternal\n    t.beta.sg1 = .5; t.beta.kin=.5; t.beta.mat = 0;\n  }\n\n  i.sharing.gamma[isel] <- ( t.beta.sg1 * i.gamma.sg1[isel] ) +\n    (t.beta.kin * i.gamma.kin[isel] ) + ( t.beta.mat* i.gamma.mat[isel] );\n  \n  i.sharing.childhood.gamma[isel] <- ( t.beta.sg1 * i.childhood.gamma.sg1[isel] ) +\n    (t.beta.kin * i.childhood.gamma.kin[isel]) + ( t.beta.mat * i.childhood.gamma.mat[isel] );\n};\n \n      \n###################################\n### Forecast 1 cycle forward in time\n###################################\n\n\ntest<-\n  forward.5yr.altqx(cycleno=as.integer(0),\n                     beta.mat=beta.mat,\n                     beta.kin=beta.kin,\n                     beta.sg1=beta.sg1,                     \n                     own.id.mat=i.own.id.mat,\n                     mom.id.mat= i.mom.id.mat,\n                     gmom.id.mat= i.gmom.id.mat,\n                     ggmom.id.mat= i.ggmom.id.mat,\n                     mom.id.kin = i.mom.id.kin,\n                     gmom.id.kin= i.gmom.id.kin,\n                     ggmom.id.kin= i.ggmom.id.kin,\n                     gggmom.id.kin= i.gggmom.id.kin,\n                     ggggmom.id.kin= i.ggggmom.id.kin,\n                     gggggmom.id.kin=  i.gggggmom.id.kin,\n                     kinship3.id = i.kinship3.id,\n                     kinship4.id = i.kinship4.id,\n                     kinship5.id = i.kinship5.id,\n                     group.id.anc= i.group.id.anc,\n                     own.id.yr= i.own.id.yr,\n                     mom.id.yr=  i.mom.id.yr,\n                     gmom.id.yr =  i.gmom.id.yr,\n                     ggmom.id.yr = i.ggmom.id.yr,\n                     gggmom.id.yr= i.gggmom.id.yr,\n                     group.id.mat= i.group.id.mat,\n                     gamma.mat= i.gamma.mat,\n                     childhood.gamma.mat = i.childhood.gamma.mat,\n                     gamma.kin = i.gamma.kin,\n                     childhood.gamma.kin = i.childhood.gamma.mat,\n                     gamma.anc = i.gamma.anc, #new\n                     childhood.gamma.anc = i.childhood.gamma.anc, #new\n                     ##own.id.sg1 = i.own.id.sg1,  # DELETE\n                     mom.id.sg1 = i.mom.id.sg1,\n                     gmom.id.sg1 = i.gmom.id.sg1,\n                     ggmom.id.sg1 = i.ggmom.id.sg1,\n                     group.id.sg1 = i.group.id.sg1,\n                     gamma.sg1 = i.gamma.sg1,\n                     childhood.gamma.sg1 = i.childhood.gamma.sg1,\n                     sharing.gamma = i.sharing.gamma,\n                     sharing.childhood.gamma = i.sharing.childhood.gamma,\n                     subPop.id = i.subPop.id,       #new vector to track subpopulations\n                     gene = i.genes,\n                     age = i.ages,      \n                     max.age = as.integer(max.age) ,\n                     e.fertility = e.fert,\n                     e.mortality =  e.mort,\n                     e.production =  e.prod,\n                     e.cproduction=  e.cprod,\n                     cproduction.cap = cprod.cap,\n                     e.density =  e.dens,\n                     #pop.size= length(i.own.id.mat),\n                     resource.size = Cresources\n                     );\n\n\n\n\nrm(i.own.id.mat,i.mom.id.mat, i.gmom.id.mat, i.ggmom.id.mat,\n   i.gggmom.id.mat, i.kinship3.id, i.kinship4.id, i.kinship5.id, i.group.id.mat, i.gamma.mat,\n   i.gggmom.id.kin,i.gggmom.id.yr,i.ggmom.id.kin,\n   i.ggmom.id.yr,i.gmom.id.kin ,i.gmom.id.yr,\n   i.mom.id.kin , i.mom.id.yr ,i.own.id.yr,\n   i.childhood.gamma.mat, i.own.id.sg1, i.mom.id.sg1, i.gmom.id.sg1,\n   i.ggmom.id.sg1, i.group.id.sg1, i.gamma.sg1, i.childhood.gamma.sg1,\n   i.genes, i.ages)\n\n\n###################################\n## Reinitialize test using previous simulation, if appropriate\n###################################\n#load(\"sim107.test.Rbin\");               #reloads test, final state from sim107\n\n## reset mutation load to zero\ntest$gene <- ( zero * test$gene);\n\n## convert to integer to save memory and increase speed\n#test<- f.setmode(test);\n\n########################\n## Forecast Ncycles years\n########################\nyx.series <- array(NA, dim=c(Ncycles,16,length(subPopTypes) ) );\nsim.results <-  array(NA, dim=c(Ncycles,16,length(subPopTypes) ) );\npop.series <-  array(NA, dim=c(Ncycles,16,length(subPopTypes) ) );\n\n\ngamma.series <- array(NA, dim=c(Ncycles,16,length(subPopTypes) ) );\nchildhood.gamma.series <- array(NA, dim=c(Ncycles,16,length(subPopTypes) ) );\ndensity.series <- matrix(NA,Ncycles,length(subPopTypes));\nfusion.series <-  matrix(NA,Ncycles,length(subPopTypes));\nfission.series <- matrix(NA,Ncycles,length(subPopTypes));\nmat.series <-  matrix(NA,Ncycles,length(subPopTypes));\nanc.series <-  matrix(NA,Ncycles,length(subPopTypes));\nkinship3.series <-  matrix(NA,Ncycles,length(subPopTypes));\nkinship4.series <-  matrix(NA,Ncycles,length(subPopTypes));\nkinship5.series <-  matrix(NA,Ncycles,length(subPopTypes));\nsg.series       <-  matrix(NA,Ncycles,length(subPopTypes));\n\nqx.series <-  NA+array(0, dim=c(Ncycles,16,length(subPopTypes) ) );\n\n# 100K size test\ntoo.high <- ifelse(length(test$own.id.mat)> i.popsize,\"yes\",\"no\");\n\n# homeostasis correction flags\ndo.homeo.resource <- FALSE;                #toggle resource homeostasis\ndo.2Xpopsize.check     <- TRUE ;                #toggle 2Xpopsize  chop down\n\n# interval at which to apply homeostatic checks\nhomeo.N <- 100;\n\n# window to average over to determine if pop is growing or shrinking\npop.avgwindow <- 20;\n\nset.seed(999);\n\nfor (year in seq(Ncycles)){\ntest <-\n  forward.5yr.altqx(cycleno=as.integer(year),\n                     beta.mat=beta.mat,\n                     beta.kin=beta.kin,\n                     beta.sg1=beta.sg1,\n                     own.id.mat=test$own.id.mat,\n                     mom.id.mat=test$mom.id.mat,\n                     gmom.id.mat=test$gmom.id.mat,\n                     ggmom.id.mat=test$ggmom.id.mat,\n                     mom.id.kin= test$mom.id.kin,\n                     gmom.id.kin=test$gmom.id.kin,\n                     ggmom.id.kin=test$ggmom.id.kin,\n                     gggmom.id.kin=test$gggmom.id.kin,\n                     ggggmom.id.kin=test$ggggmom.id.kin,\n                     gggggmom.id.kin=test$gggggmom.id.kin,\n                     kinship3.id = test$kinship3.id,\n                     kinship4.id = test$kinship4.id,\n                     kinship5.id = test$kinship5.id,\n                     group.id.anc=test$group.id.anc,\n                     own.id.yr= test$own.id.yr,\n                     mom.id.yr=  test$mom.id.yr,\n                     gmom.id.yr =  test$gmom.id.yr,\n                     ggmom.id.yr = test$ggmom.id.yr,\n                     gggmom.id.yr=  test$gggmom.id.yr,\n                     group.id.mat= test$group.id.mat,\n                     gamma.mat= test$gamma.mat,\n                     childhood.gamma.mat = test$childhood.gamma.mat,\n                     gamma.kin = test$gamma.kin,\n                     childhood.gamma.kin = test$childhood.gamma.kin,\n                     gamma.anc=test$gamma.anc,\n                     childhood.gamma.anc=test$childhood.gamma.anc,\n                     ##own.id.sg1 = test$own.id.sg1,  # DELETE\n                     mom.id.sg1 = test$mom.id.sg1,\n                     gmom.id.sg1 = test$gmom.id.sg1,\n                     ggmom.id.sg1 = test$ggmom.id.sg1,\n                     group.id.sg1 = test$group.id.sg1,\n                     gamma.sg1 = test$gamma.sg1,\n                     childhood.gamma.sg1 = test$childhood.gamma.sg1,\n                     sharing.gamma = test$sharing.gamma,\n                     sharing.childhood.gamma = test$sharing.childhood.gamma,             \n                     subPop.id = test$subPop.id,\n                     gene = test$gene,\n                     age = test$age,\n                     max.age = max.age,\n                     e.fertility = e.fert,\n                     e.mortality =  e.mort,\n                     e.production =  e.prod,\n                     e.cproduction = e.cprod,\n                     cproduction.cap = cprod.cap,\n                     e.density =  e.dens,\n                     #pop.size= length(test$own.id.mat),\n                     resource.size = Cresources\n                     );\n\n\n \n  #sim.results[year,] <- test$mean.harm\n  gamma.series[year,,] <-  tapply(test$sharing.gamma,list(factor(test$age,levels=0:15),\n                                  factor(test$subPop.id,levels=seq(subPopTypes) )),mean);\n  childhood.gamma.series[year,,] <-  tapply(test$sharing.childhood.gamma,list(factor(test$age,levels=0:15),\n                                                          factor(test$subPop.id,levels=seq(subPopTypes) )),mean);\n  t.age.factor <- factor(test$age,levels=0:15);\n  t.subpop.factor <- factor(test$subPop.id,levels=seq(subPopTypes));\nfor(i in seq(subPopTypes)){\n  # avg mutation load, by age class, for each subpop\n  t.subpop<- test$subPop.id==i;\n  if(any(t.subpop)){                    #if there is a 0 subpop, output remains NA\n    sim.results[year,,i] <-apply(test$gene[t.subpop,, drop=F],2,mean);\n     anc.series[year,i] <-      mean( table(test$group.id.anc[t.subpop]));\n    #kinship3.series[year,i] <- mean(table(test$kinship3.id[t.subpop]));\n    #kinship4.series[year,i] <- mean(table(test$kinship4.id[t.subpop]));\n    kinship5.series[year,i] <- mean(table(test$kinship5.id[t.subpop]));\n    mat.series[year,i]    <-   mean(table(test$group.id.mat[t.subpop]));\n    sg.series[year,i]      <-  mean(table(test$group.id.sg1[t.subpop])) ;\n  }\n}\n\n  pop.series[year,,] <- tapply(test$own.id.mat,list(t.age.factor,t.subpop.factor),length)\n  yx.series[year,,]  <-  tapply(test$yx,list(t.age.factor,t.subpop.factor),mean);\n\n  t.totc <- tapply( cxz[ test$age + 1 ], t.subpop.factor, sum );\n  density.series[year,] <- t.totc/Cresources\n  fusion.series[year,] <- test$Pfusions;\n  fission.series[year,] <- test$Pfissions;\n \n\n print(paste(\"cycle \",year));\n  \n if( (year %% Ncheckpoint) == 0){\n    print(paste(date(), \"CHECKPOINT:  Completed \", start.year + year,\" of \", start.year + Ncycles));\n    # save the results to this point\n    save.image(file=\".CheckPoint\",compress=TRUE);\n  }\n\n  # every homeo.N years, adjust the resource.target, if adj. enabled\n  if ( do.homeo.resource && (year %% homeo.N == 0) ) {\n    print(\"...Resource adjustment...\");\n    # large and growing pop -- then shrink it.\n    t.totP <- apply(pop.series[(year-pop.avgwindow+1):year,],1,sum);\n    if ( (t.totP[pop.avgwindow] > i.popsize) && ( mean(exp(diff(log(t.totP)))) > 1 ) ) {\n       #Pop is above target size and is growing, so decrease available resources\n      if (too.high==\"no\") {adjust.increment <- ifelse( adjust.increment>.001, adjust.increment*0.9, .001) }\n      too.high <- c(\"yes\")\n      resources <- resources - (adjust.increment*resources);\n      Cresources <- Cresources - (adjust.increment*Cresources);\n    }\n    # small and shrinking pop -- then expand it\n    if ( (t.totP[pop.avgwindow] < i.popsize)  && ( mean(exp(diff(log(t.totP)))) < 1 )   ) {\n                                        #Pop is below target size and is declining, so increase resources\n      if (too.high==\"yes\") {adjust.increment <- ifelse(adjust.increment>.001, adjust.increment*0.9, .001) }\n      too.high <- c(\"no\")\n      resources <- resources + (adjust.increment*resources);\n      Cresources <- Cresources + (adjust.increment*Cresources);\n     \n    }\n  }\n\n  density.series[year,] <-  t.totc/Cresources\n\n#if exceeds twice the normative population size, chop it down\n  if (do.2Xpopsize.check && length(test$own.id.mat)> 2*i.popsize){\n   # Select i.popsize folks at random\n    print(\".....Popsize forced reduction....\");\n    test<- f.subsamptest(test,i.popsize); \n  }\n\n}\n\nend.time <- date()\n#rbind(test$own.id.mat,test$mom.id.mat,test$gmom.id.mat,test$ggmom.id.mat, test$gggmom.id.mat,test$kinship.id)[,1:10]\n# final results saved\nsave.image(file=\".CheckPoint\",compress=TRUE);\n\n",
    "created" : 1547392235396.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1960469987",
    "id" : "CE45321D",
    "lastKnownWriteTime" : 1547836817,
    "last_content_update" : 1547836817432,
    "path" : "/data/nta0/boe/EvoSims/sim168D_2019/sim168.r",
    "project_path" : "sim168.r",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}